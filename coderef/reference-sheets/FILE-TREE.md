# FileTree - Resource Sheet

**Category:** UI Component
**Type:** React Component (Client Component)
**File:** `packages/dashboard/src/components/coderef/FileTree.tsx`
**Created:** 2026-01-02
**Lines of Code:** 358

---

**Generated by:** Resource Sheet Generation Workflow
**Timestamp:** 2026-01-02
**Auto-fill Rate:** Manual (comprehensive analysis)

---

## Executive Summary

**Element:** FileTree
**Category:** UI Component
**Purpose:** Hierarchical file/directory tree component with support for favorites management, folder filtering, and hybrid local/API access modes

**Key Responsibilities:**
- Load project tree data via hybrid router (local filesystem or API)
- Render recursive file/directory hierarchy using FileTreeNode
- Filter tree to specific subfolder (e.g., show only `coderef/` directory)
- Display favorites-only view using FavoritesList component
- Show access mode indicator (Local vs API)
- Handle loading, error, and empty states
- Coordinate favorites operations (toggle, group assignment)

**Not Responsible For:**
- Individual node rendering (delegated to FileTreeNode)
- File content display (delegated to FileViewer)
- Favorites storage (delegated to parent widget)
- Project selection (delegated to ProjectSelector)

---

## Architecture Overview

### Component Hierarchy

```
FileTree (this component)
â”œâ”€â”€ Empty State (no project selected)
â”œâ”€â”€ Loading State (Loader2 spinner)
â”œâ”€â”€ Error State (AlertCircle + error message)
â”œâ”€â”€ Favorites Mode
â”‚   â””â”€â”€ FavoritesList (favorites-only view)
â””â”€â”€ Tree Mode
    â”œâ”€â”€ Access Mode Indicator (Local/API badge)
    â””â”€â”€ FileTreeNode[] (recursive rendering)
        â”œâ”€â”€ FileTreeNode (directory)
        â”‚   â””â”€â”€ FileTreeNode[] (children)
        â””â”€â”€ FileTreeNode (file)
```

**Design Rationale:**
- **Hybrid routing:** Supports both Electron local filesystem and browser API access
- **Recursive composition:** FileTreeNode renders itself recursively for clean code
- **Mode indicator:** Visual feedback for performance characteristics (local = fast)
- **Separate favorites view:** FavoritesList optimized for grouped favorites display

### File Structure

**Location:** `packages/dashboard/src/components/coderef/FileTree.tsx`

**Related Files:**
- `components/coderef/FileTreeNode.tsx` - Individual tree node rendering
- `components/coderef/FavoritesList.tsx` - Favorites-only view
- `lib/coderef/hybrid-router.ts` - Hybrid local/API tree loading
- `lib/coderef/types.ts` - TypeScript interfaces (Project, TreeNode, AccessMode)
- `lib/coderef/favorites-types.ts` - Favorites data structures

**Organization Strategy:**
- FileTree handles data loading and filtering logic
- FileTreeNode handles individual node UI and interactions
- FavoritesList handles grouped favorites display
- Hybrid router abstracts local vs API access

### Dependencies

**Internal Dependencies:**
- `@/lib/coderef/hybrid-router` - loadProjectTree() function
- `@/lib/coderef/types` - Project, TreeNode, AccessMode interfaces
- `@/lib/coderef/favorites-types` - FavoritesData interface
- `./FileTreeNode` - Recursive node rendering
- `./FavoritesList` - Favorites view component

**External Dependencies:**
- `react` (^18.2.0) - useState, useEffect hooks
- `lucide-react` - Icons (Loader2, AlertCircle, FolderOpen, Zap, Cloud)

**Dependency Choices:**
- **Hybrid router abstraction:** Separates local/API logic from UI component
- **lucide-react icons:** Consistent icon library across dashboard
- **No virtualization:** Tree not virtualized (acceptable for <1000 nodes)

### Architectural Pattern

**Pattern:** Smart Container with Recursive Composition

**Rationale:**
- Container handles data loading and state management
- Recursive FileTreeNode pattern keeps code DRY (don't repeat directory rendering logic)
- Filtering applied at container level (cleaner than filtering in each node)
- Mode switching (favorites vs tree) handled via conditional rendering

**Alternative Considered:** Flat list with indentation
**Rejected Because:**
- Recursive structure matches directory semantics naturally
- Expanding/collapsing folders easier with component tree
- Parent-child relationships explicit in component hierarchy

---

## State Management

### State Variables

**1. tree: TreeNode[]**
- **Purpose:** Current file/directory tree data
- **Initial Value:** `[]`
- **Updated By:** `loadTree()` async function, `useEffect` on project change

**2. loading: boolean**
- **Purpose:** Loading state for async tree fetch
- **Initial Value:** `false`
- **Overridden By:** `externalLoading` prop (for CodeRef mode)

**3. error: string | null**
- **Purpose:** Error message if tree loading fails
- **Initial Value:** `null`
- **Cleared:** On successful tree load, on project change

**4. accessMode: AccessMode | null ('local' | 'api')**
- **Purpose:** Indicates whether tree was loaded from local filesystem or API
- **Initial Value:** `null`
- **Set By:** `loadProjectTree()` return value
- **Display:** Access mode indicator badge

### State Update Patterns

**Pattern 1: Hybrid Tree Loading**
```tsx
const loadTree = async (proj: Project) => {
  try {
    setLoading(true);
    setError(null);
    const result = await loadProjectTree(proj);
    setTree(result.data);           // Tree data
    setAccessMode(result.mode);     // Local or API
  } catch (err) {
    setError((err as Error).message);
    setTree([]);
    setAccessMode(null);
  } finally {
    setLoading(false);
  }
};
```

**Pattern 2: Custom Tree Override (CodeRef Mode)**
```tsx
useEffect(() => {
  if (customTree) {
    setTree(customTree);
    setError(null);
    setAccessMode(null);  // No access mode for custom tree
  }
}, [customTree]);
```

**Why separate useEffects?**
- `customTree` prop takes precedence over `project` prop
- Prevents loading tree from project when custom tree provided
- Clearer intent: "if custom tree, use it; otherwise load from project"

---

## Filtering Logic

### Folder Filtering (filterPath)

**Purpose:** Show only a specific subfolder's children (e.g., `coderef/`)

**Algorithm:**
```typescript
const filterTreeToFolder = (nodes: TreeNode[], folderName: string): TreeNode[] => {
  for (const node of nodes) {
    // Match found: return children
    if (node.type === 'directory' && node.name === folderName) {
      return node.children || [];
    }
    // Recursively search in children
    if (node.children) {
      const found = filterTreeToFolder(node.children, folderName);
      if (found.length > 0) return found;
    }
  }
  return [];
};
```

**Complexity:** O(n) where n = total nodes in tree
**Why recursive?** Folder could be at any depth (e.g., `src/lib/coderef`)

**Use Case:**
```tsx
<FileTree filterPath="coderef" />
// Shows only coderef/ directory contents, hides rest of project
```

### Favorites Filtering (showOnlyFavorites)

**Purpose:** Show only favorited items (and their parent directories)

**Algorithm:**
```typescript
const filterTreeToFavorites = (nodes: TreeNode[]): TreeNode[] => {
  const filtered: TreeNode[] = [];

  for (const node of nodes) {
    const nodeFavorited = isFavorite(node.path);
    const childrenFiltered = node.children ? filterTreeToFavorites(node.children) : [];

    // Include if favorited OR if any children are favorited (keep parent structure)
    if (nodeFavorited || childrenFiltered.length > 0) {
      filtered.push({
        ...node,
        children: childrenFiltered.length > 0 ? childrenFiltered : node.children,
      });
    }
  }

  return filtered;
};
```

**Why include parent directories?**
- Preserves tree structure (user sees full path to favorited file)
- Allows expanding parent to see favorite children

**Example:**
```
Original Tree:
  src/
    lib/
      utils.ts [FAVORITE]
      other.ts

Filtered Tree:
  src/
    lib/
      utils.ts [FAVORITE]
  (other.ts is hidden)
```

### Filter Application Order

**Pipeline:**
```typescript
let displayTree = tree;

// 1. Folder filter first
if (filterPath) {
  displayTree = filterTreeToFolder(displayTree, filterPath);
}

// 2. Favorites filter second
if (showOnlyFavorites) {
  displayTree = filterTreeToFavorites(displayTree);
}
```

**Why this order?**
- Folder filter reduces tree size first (performance)
- Favorites filter then applied to smaller tree
- Combining both: "Show favorites in coderef/ folder only"

---

## Integration Points

### Internal Integrations

**Components that use this:**
- `widgets/coderef-explorer/CodeRefExplorerWidget.tsx` - Main widget
  - Passes: `project`, `selectedPath`, `onFileClick`, favorites props
  - Receives: File click events

**Components this uses:**
- **FileTreeNode** - Recursive node rendering
  - Passes: `node`, `depth`, `selectedPath`, favorites callbacks
  - Renders directory/file icons, expansion controls, favorites star
- **FavoritesList** - Favorites-only view
  - Passes: `favoritesData`, group management callbacks
  - Displays grouped favorites with drag-and-drop

### External Integrations

**Hybrid Router (local + API):**
```typescript
const result = await loadProjectTree(proj);
// result = { data: TreeNode[], mode: 'local' | 'api' }
```

**Electron IPC (local mode):**
- Calls `window.electron.coderef.getTree(path)`
- Returns tree immediately (no HTTP latency)
- Requires Electron preload script

**HTTP API (API mode):**
- Calls `GET /api/coderef/tree?projectId={id}`
- Returns tree via JSON response
- Fallback when local mode unavailable (browser)

### Data Flow

**Input:**
```typescript
<FileTree
  project={selectedProject}        // Project to load tree from
  customTree={aggregatedTree}      // Or custom tree data
  selectedPath="/src/index.ts"     // Active file
  onFileClick={(node) => {...}}    // Click handler
  filterPath="coderef"             // Optional filter
  showOnlyFavorites={true}         // Favorites mode
  favoritesData={favoritesData}    // Favorites data
  // ... callbacks
/>
```

**Processing:**
1. Load tree from project (or use customTree)
2. Apply folder filter if specified
3. Apply favorites filter if specified
4. Render filtered tree with FileTreeNode

**Output:**
- Rendered tree UI
- File click events emitted via `onFileClick(node)`
- Favorites toggle events via `onToggleFavorite(path, group)`

---

## View Modes

### Projects Mode (Default)

**Behavior:**
- Load full project tree
- Show all files/directories
- Optional folder filter (e.g., `filterPath="coderef"`)

**UI:**
```
â””â”€â”€ src/
    â”œâ”€â”€ components/
    â”œâ”€â”€ lib/
    â””â”€â”€ index.ts
```

### CodeRef Mode (customTree)

**Behavior:**
- Use provided `customTree` prop (bypasses project loading)
- Typically aggregated `coderef/` trees from multiple projects
- No access mode indicator (custom data source)

**UI:**
```
â””â”€â”€ coderef/
    â”œâ”€â”€ workorder/
    â”œâ”€â”€ foundation-docs/
    â””â”€â”€ standards/
```

### Favorites Mode (showOnlyFavorites)

**Behavior:**
- Render `FavoritesList` component instead of tree
- Show grouped favorites (if groups exist)
- Allow drag-and-drop to assign favorites to groups

**UI:**
```
ðŸ“Œ Favorites
  Ungrouped
    âœ“ src/utils.ts
  Backend (3)
    âœ“ src/api/routes.ts
    âœ“ src/db/schema.ts
```

---

## Empty & Error States

### Empty State 1: No Project Selected

**Condition:** `!project && !customTree`

**UI:**
```tsx
<FolderOpen className="w-12 h-12 opacity-50" />
<p>Select a project to browse files</p>
```

### Empty State 2: Filtered Tree Empty

**Condition:** `displayTree.length === 0` (after filtering)

**UI:**
```tsx
<FolderOpen className="w-12 h-12 opacity-50" />
<p>
  {filterPath ? `No ${filterPath}/ folder found` : 'No files found'}
</p>
```

### Loading State

**Condition:** `loading === true` or `externalLoading === true`

**UI:**
```tsx
<Loader2 className="animate-spin" />
<p>Loading file tree...</p>
```

### Error State

**Condition:** `error !== null`

**UI:**
```tsx
<AlertCircle className="text-red-500" />
<strong>Error loading tree:</strong>
<div>{error}</div>
```

**Error Sources:**
- Network failure (API mode)
- IPC failure (Electron mode)
- Permission denied (filesystem access)
- Invalid project path

---

## Access Mode Indicator

### Purpose

**Visual Feedback:** Show user whether tree was loaded from local filesystem or API

**Why it matters:**
- **Local mode:** Instant tree loading (no network latency)
- **API mode:** Slower (HTTP round-trip), but works in browser

### UI

**Local Mode:**
```tsx
<Zap className="text-green-500" />
<span>Local Mode (Fast)</span>
```

**API Mode:**
```tsx
<Cloud className="text-blue-500" />
<span>API Mode</span>
```

**When Hidden:**
- `customTree` provided (no loading, no mode)
- `accessMode === null` (not loaded yet)

---

## Performance Considerations

### Performance Budgets

**Metrics:**
- Tree loading time (local vs API)
- Filtering time (folder + favorites)
- Render time (recursive FileTreeNode)

**Targets:**
- **Local mode loading:** <100ms (Electron IPC)
- **API mode loading:** <500ms (HTTP)
- **Filtering:** <50ms (pure JavaScript, no DOM)
- **Render:** <200ms for 500 nodes

### Bottlenecks

**1. Non-Virtualized Rendering**
- **Issue:** All nodes rendered at once
- **Impact:** Slow for projects with 1000+ files
- **Mitigation:** Consider react-window or react-virtualized

**2. Recursive Filtering**
- **Issue:** O(n) complexity for each filter
- **Impact:** Minimal for typical trees (<500 nodes)
- **Mitigation:** Acceptable, caching not needed

**3. Re-Rendering on Favorites Toggle**
- **Issue:** Parent re-renders trigger all FileTreeNode re-renders
- **Impact:** Minor jank when toggling favorites
- **Mitigation:** Memoize FileTreeNode with React.memo

### Optimization Opportunities

**Quick Wins:**

**1. Memoize Filtered Tree**
```tsx
const displayTree = useMemo(() => {
  let result = tree;
  if (filterPath) result = filterTreeToFolder(result, filterPath);
  if (showOnlyFavorites) result = filterTreeToFavorites(result);
  return result;
}, [tree, filterPath, showOnlyFavorites, isFavorite]);
```

**2. Memoize FileTreeNode**
```tsx
const MemoizedFileTreeNode = React.memo(FileTreeNode);
```

---

## Testing Strategy

### Coverage Gaps

- [ ] Test folder filtering with nested directories
- [ ] Test favorites filtering preserves parent structure
- [ ] Test error handling (network failure, invalid project)
- [ ] Test access mode indicator display
- [ ] Test switching between tree/favorites modes
- [ ] Test large trees (1000+ nodes)

### Recommended Tests

**High Priority:**

**1. Test folder filtering**
```typescript
test('should filter tree to coderef folder', () => {
  const tree = [
    { name: 'src', type: 'directory', children: [...] },
    { name: 'coderef', type: 'directory', children: [
      { name: 'workorder', type: 'directory', children: [] }
    ]}
  ];

  render(<FileTree customTree={tree} filterPath="coderef" />);
  expect(screen.getByText('workorder')).toBeInTheDocument();
  expect(screen.queryByText('src')).not.toBeInTheDocument();
});
```

**2. Test favorites filtering**
```typescript
test('should show only favorited items and their parents', () => {
  const isFavorite = (path: string) => path === '/src/lib/utils.ts';

  render(<FileTree tree={tree} showOnlyFavorites isFavorite={isFavorite} />);

  expect(screen.getByText('src')).toBeInTheDocument();     // Parent
  expect(screen.getByText('lib')).toBeInTheDocument();     // Parent
  expect(screen.getByText('utils.ts')).toBeInTheDocument(); // Favorite
  expect(screen.queryByText('other.ts')).not.toBeInTheDocument();
});
```

---

## Footer

**Generated by:** Resource Sheet Generation Workflow
**Timestamp:** 2026-01-02
**Modules Used:** architecture, integration, state-management, filtering, performance
**Complexity Score:** High (358 lines, recursive algorithms, hybrid routing, multiple view modes)

**Recommended Next Steps:**
1. Implement virtual scrolling for large trees
2. Add memoization for filtered tree
3. Add comprehensive filtering tests
4. Measure render performance with large trees

---

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
