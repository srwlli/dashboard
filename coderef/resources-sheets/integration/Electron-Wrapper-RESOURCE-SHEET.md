---
agent: Claude Sonnet 4.5
date: "2026-01-12"
task: UPDATE
subject: Electron Wrapper
parent_project: coderef-dashboard
category: integration
version: 1.0.0
related_files:
  - packages/dashboard/src/lib/electron/wrapper.ts
status: APPROVED
---

# Electron Wrapper - Resource Sheet

**Category:** Application Shell
**Type:** Electron Main Process & Preload
**Files:** `packages/electron-app/src/main.ts`, `packages/electron-app/src/preload.ts`
**Created:** 2026-01-04
**Updated:** 2026-01-04
**Lines of Code:** ~250 (Main + Preload)

---

**Generated by:** Resource Sheet Generation Workflow
**Timestamp:** 2026-01-04
**Auto-fill Rate:** Manual (comprehensive analysis)

---

## Executive Summary

**Element:** Electron Wrapper
**Category:** Application Shell
**Purpose:** Provides a native desktop environment for the CodeRef Dashboard web application, enabling system-level integrations (file system access) while maintaining web technologies for the UI.

**Key Responsibilities:**
- **Process Management:** Lifecycle management of the application window and Next.js server (in production).
- **Native Integration:** Securely exposing native capabilities (File System, Dialogs) to the renderer via IPC.
- **Security Boundary:** Enforcing `contextIsolation` and `nodeIntegration: false` to prevent remote code execution.
- **Distribution:** Packaging the web application into a standalone executable (NSIS, Portable).

**Not Responsible For:**
- **UI Rendering:** Delegated entirely to the Next.js application (`packages/dashboard`).
- **Heavy Computation:** Delegated to the Python backend (future integration) or API routes.

---

## Architecture Overview

### Process Model

```mermaid
graph TD
    A[Main Process (Node.js)] -->|Spawns| B[BrowserWindow]
    A -->|Spawns (Prod)| C[Next.js Server (HTTP)]
    B -->|Loads| D[Renderer Process (Web)]
    D -->|IPC| A
    C -->|Serves| D
```

**Development vs. Production:**
- **Development (`npm run dev`):** 
  - Connects to external Next.js dev server on port 3004.
  - Hot Reloading enabled.
  - DevTools open by default.
- **Production (`npm run package:win`):** 
  - Spawns internal Next.js server instance on port 9000.
  - Loads from local `dist` files.
  - DevTools disabled by default.

### File Structure

**Location:** `packages/electron-app/`

```
packages/electron-app/
├── src/
│   ├── main.ts        # Entry point, window management, IPC handlers
│   └── preload.ts     # Context bridge, API exposure
├── electron-builder.yml # Packaging configuration
└── package.json       # Dependencies (electron, electron-builder)
```

**Design Rationale:**
- **Separation of Concerns:** Electron code is isolated from the Next.js dashboard code.
- **Context Isolation:** `preload.ts` acts as the only bridge between the untrusted web content and the privileged Node.js environment.

---

## Core Components

### Main Process (`main.ts`)

**Window Management:**
- Creates a 1920x1080 default window (min 800x600).
- Intercepts navigation to prevent leaving the application origin.
- Handles standard lifecycle events (`ready`, `window-all-closed`, `activate`).

**Next.js Integration:**
```typescript
// Production Server
async function startNextServer() {
  const nextApp = createServer({ dev: false, dir: ... });
  await nextApp.prepare();
  // ... starts http server on port 9000
}
```

### IPC Bridge (`preload.ts`)

**Pattern:** `contextBridge.exposeInMainWorld`
**Exposed API:** `window.electronAPI`

**Security:**
- No direct Node.js access in renderer.
- Specific, allow-listed methods only.
- IPC channels validated (e.g., `send` only allows 'log').

---

## IPC Interface & Questions

### How does the Frontend talk to the Backend?

The frontend uses the `window.electronAPI` object. This is typed globally in `types.d.ts` (and locally in `preload.ts`).

**1. System Info**
- `getVersion()`: Returns app version.
- `getPlatform()`: Returns OS platform (win32, darwin, linux).

**2. File System (fs)**
- `fs.selectDirectory()`: Opens native folder picker. Returns path or null.
- `fs.stat(path)`: Returns `{ isDirectory, isFile }`.
- `fs.readdir(path)`: Returns `{ name, isDirectory }[]`.
- `fs.readFile(path)`: Returns file content as UTF-8 string.
- `fs.validatePath(path)`: Checks existence and access without throwing (returns `{ valid, reason }`).

**3. Messaging**
- `send(channel, ...args)`: One-way message to main (currently limited to 'log').
- `receive(channel, callback)`: Listen for main process messages (currently limited to 'message').

### How is Security Handled?

**1. Context Isolation (`contextIsolation: true`)**
The renderer process (Next.js) runs in a separate context from the Preload script. It cannot access `window.require`, `process`, or `fs` directly.

**2. Node Integration Disabled (`nodeIntegration: false`)**
Prevents `require()` calls in the DOM, mitigating XSS risks.

**3. Path Validation**
IPC handlers in `main.ts` validate inputs. For example, `fs:validatePath` uses `fs.access` internally and catches errors to return safe status objects rather than leaking stack traces or crashing.

---

## Building & Packaging

### How do I build the app?

The build process uses `electron-builder`.

**Commands:**
- `npm run package:win`: Builds for Windows (x64).

**Configuration (`electron-builder.yml`):**
- **App ID:** `com.coderef.dashboard`
- **Output:** `dist`
- **Targets:** 
  - `nsis` (Installer)
  - `portable` (Standalone EXE)
- **Included Files:**
  - `dist/**/*` (Compiled Electron main/preload)
  - `../dashboard/.next/**/*` (Next.js build artifacts)

**Workflow:**
1. **Build Next.js:** `cd packages/dashboard && npm run build`
2. **Compile TS:** `cd packages/electron-app && tsc`
3. **Package:** `electron-builder` bundles the Electron binary, the `dist` folder, and the Next.js `.next` folder into the final executable.

### How are updates handled?
*Currently not implemented.* The architecture supports `electron-updater` via `electron-builder`'s publish configuration, but `publish` is currently set to `never`.

---

## Common Questions & Troubleshooting

### Q: Why does `fs.readFile` only return strings?
A: It is hardcoded to `'utf-8'` in `main.ts`. For binary files, the handler would need to be updated to return a Buffer or Base64 string.

### Q: Can I run this without building?
A: Yes.
1. Start Next.js: `cd packages/dashboard && npm run dev` (Port 3004)
2. Start Electron: `cd packages/electron-app && npm run dev`

### Q: How do I add a new Native Feature?
1. **Main:** Add `ipcMain.handle('channel', ...)` in `src/main.ts`.
2. **Preload:** Add wrapper in `contextBridge` in `src/preload.ts`.
3. **Type:** Update `Window` interface in `src/preload.ts` (and `types.d.ts` if shared).
4. **Renderer:** Call `window.electronAPI.newFeature()`.

---

## Integration Points

### Backend Integration (Future)
The `backend:health` IPC handler is currently a stub.
```typescript
ipcMain.handle('backend:health', async () => {
  // TODO: Implement backend health check
  return { status: 'ok' };
});
```
*Plan:* Launch Python executable as a subprocess in `main.ts` and proxy requests or manage lifecycle.

### Navigation Handling
`will-navigate` event is intercepted to prevent users from dropping files onto the window and navigating away from the app.
```typescript
mainWindow.webContents.on('will-navigate', (event, url) => {
  if (parsedUrl.origin !== parsedStart.origin) {
    event.preventDefault();
  }
});
```

---

**Complexity Score:** Low (Clean, standard Electron boilerplate)
**Modules Used:** electron, next.js, electron-builder
