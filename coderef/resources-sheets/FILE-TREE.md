# FileTree - Resource Sheet

**Category:** UI Component
**Type:** React Component (Client Component)
**File:** `packages/dashboard/src/components/coderef/FileTree.tsx`
**Created:** 2026-01-02
**Lines of Code:** 455
**Last Updated:** 2026-01-09

---

**Generated by:** Resource Sheet Generation Workflow
**Timestamp:** 2026-01-02
**Auto-fill Rate:** Manual (comprehensive analysis)

---

## Executive Summary

**Element:** FileTree
**Category:** UI Component
**Purpose:** Hierarchical file/directory tree component with support for favorites management, folder filtering, and hybrid local/API access modes

**Key Responsibilities:**
- Load project tree data via hybrid router (local filesystem or API)
- Render recursive file/directory hierarchy using FileTreeNode
- Filter tree to specific subfolder (e.g., show only `coderef/` directory)
- Display favorites-only view using FavoritesList component
- Show access mode indicator (Local vs API)
- Handle loading, error, and empty states
- Coordinate favorites operations (toggle, group assignment)
- Build move submenu for file operations across projects
- Refresh tree after file operations (deletion, move)

**Not Responsible For:**
- Individual node rendering (delegated to FileTreeNode)
- File content display (delegated to FileViewer)
- Favorites storage (delegated to parent widget)
- Project selection (delegated to ProjectSelector)

---

## Architecture Overview

### Component Hierarchy

```
FileTree (this component)
â”œâ”€â”€ Empty State (no project selected)
â”œâ”€â”€ Loading State (Loader2 spinner)
â”œâ”€â”€ Error State (AlertCircle + error message)
â”œâ”€â”€ Favorites Mode
â”‚   â””â”€â”€ FavoritesList (favorites-only view)
â””â”€â”€ Tree Mode
    â”œâ”€â”€ Access Mode Indicator (Local/API badge)
    â””â”€â”€ FileTreeNode[] (recursive rendering)
        â”œâ”€â”€ FileTreeNode (directory)
        â”‚   â””â”€â”€ FileTreeNode[] (children)
        â””â”€â”€ FileTreeNode (file)
```

**Design Rationale:**
- **Hybrid routing:** Supports both Electron local filesystem and browser API access
- **Recursive composition:** FileTreeNode renders itself recursively for clean code
- **Mode indicator:** Visual feedback for performance characteristics (local = fast)
- **Separate favorites view:** FavoritesList optimized for grouped favorites display

### File Structure

**Location:** `packages/dashboard/src/components/coderef/FileTree.tsx`

**Related Files:**
- `components/coderef/FileTreeNode.tsx` - Individual tree node rendering
- `components/coderef/FavoritesList.tsx` - Favorites-only view
- `components/coderef/ContextMenu.tsx` - Context menu types (ContextMenuItem)
- `lib/coderef/hybrid-router.ts` - Hybrid local/API tree loading
- `lib/coderef/types.ts` - TypeScript interfaces (Project, TreeNode, AccessMode)
- `lib/coderef/favorites-types.ts` - Favorites data structures
- `contexts/ProjectsContext.tsx` - Projects context (useProjects hook)

**Organization Strategy:**
- FileTree handles data loading and filtering logic
- FileTreeNode handles individual node UI and interactions
- FavoritesList handles grouped favorites display
- Hybrid router abstracts local vs API access

### Dependencies

**Internal Dependencies:**
- `@/lib/coderef/hybrid-router` - loadProjectTree() function
- `@/lib/coderef/types` - Project, TreeNode, AccessMode interfaces
- `@/lib/coderef/favorites-types` - FavoritesData interface
- `@/contexts/ProjectsContext` - useProjects() hook for project list
- `./FileTreeNode` - Recursive node rendering
- `./FavoritesList` - Favorites view component
- `./ContextMenu` - ContextMenuItem type for move submenu

**External Dependencies:**
- `react` (^18.2.0) - useState, useEffect hooks
- `lucide-react` - Icons (Loader2, AlertCircle, FolderOpen, Folder, Zap, Cloud)

**Dependency Choices:**
- **Hybrid router abstraction:** Separates local/API logic from UI component
- **lucide-react icons:** Consistent icon library across dashboard
- **No virtualization:** Tree not virtualized (acceptable for <1000 nodes)

### Architectural Pattern

**Pattern:** Smart Container with Recursive Composition

**Rationale:**
- Container handles data loading and state management
- Recursive FileTreeNode pattern keeps code DRY (don't repeat directory rendering logic)
- Filtering applied at container level (cleaner than filtering in each node)
- Mode switching (favorites vs tree) handled via conditional rendering

**Alternative Considered:** Flat list with indentation
**Rejected Because:**
- Recursive structure matches directory semantics naturally
- Expanding/collapsing folders easier with component tree
- Parent-child relationships explicit in component hierarchy

---

## State Management

### State Variables

**1. tree: TreeNode[]**
- **Purpose:** Current file/directory tree data
- **Initial Value:** `[]`
- **Updated By:** `loadTree()` async function, `useEffect` on project change

**2. loading: boolean**
- **Purpose:** Loading state for async tree fetch
- **Initial Value:** `false`
- **Overridden By:** `externalLoading` prop (for CodeRef mode)

**3. error: string | null**
- **Purpose:** Error message if tree loading fails
- **Initial Value:** `null`
- **Cleared:** On successful tree load, on project change

**4. accessMode: AccessMode | null ('local' | 'api')**
- **Purpose:** Indicates whether tree was loaded from local filesystem or API
- **Initial Value:** `null`
- **Set By:** `loadProjectTree()` return value
- **Display:** Access mode indicator badge

**5. moveSubmenu: ContextMenuItem[] | null**
- **Purpose:** Pre-built context menu structure for file move operations across projects
- **Initial Value:** `null`
- **Updated By:** `buildMoveSubmenu()` async function, `useEffect` on projects change
- **Performance:** Built once for entire tree (not per node) to avoid redundant tree loads
- **Structure:** Nested menu with projects â†’ directories â†’ subdirectories (max depth 5)

### State Update Patterns

**Pattern 1: Hybrid Tree Loading**
```tsx
const loadTree = async (proj: Project) => {
  try {
    setLoading(true);
    setError(null);
    const result = await loadProjectTree(proj);
    setTree(result.data);           // Tree data
    setAccessMode(result.mode);     // Local or API
  } catch (err) {
    setError((err as Error).message);
    setTree([]);
    setAccessMode(null);
  } finally {
    setLoading(false);
  }
};
```

**Pattern 2: Custom Tree Override (CodeRef Mode)**
```tsx
useEffect(() => {
  if (customTree) {
    setTree(customTree);
    setError(null);
    setAccessMode(null);  // No access mode for custom tree
  }
}, [customTree]);
```

**Pattern 3: Move Submenu Preloading (Performance Optimization)**
```tsx
useEffect(() => {
  const preloadMoveSubmenu = async () => {
    if (projects.length > 0) {
      const submenu = await buildMoveSubmenu();
      setMoveSubmenu(submenu);
    }
  };
  preloadMoveSubmenu();
}, [projects]);
```

**Why preload?**
- Builds move menu structure once for entire tree
- Avoids loading project trees repeatedly for each FileTreeNode
- Menu structure cached until projects change

**Pattern 4: Tree Refresh Callback**
```tsx
const handleTreeRefresh = () => {
  if (project && !customTree) {
    loadTree(project);
  }
};
```

**Why separate callback?**
- Called after file operations (delete, move) to update tree
- Passed to FileTreeNode and FavoritesList for refresh capability
- Only refreshes if in Projects mode (not CodeRef mode)

**Why separate useEffects?**
- `customTree` prop takes precedence over `project` prop
- Prevents loading tree from project when custom tree provided
- Clearer intent: "if custom tree, use it; otherwise load from project"

---

## Filtering Logic

### Folder Filtering (filterPath)

**Purpose:** Show only a specific subfolder's children (e.g., `coderef/`)

**Algorithm:**
```typescript
const filterTreeToFolder = (nodes: TreeNode[], folderName: string): TreeNode[] => {
  for (const node of nodes) {
    // Match found: return children
    if (node.type === 'directory' && node.name === folderName) {
      return node.children || [];
    }
    // Recursively search in children
    if (node.children) {
      const found = filterTreeToFolder(node.children, folderName);
      if (found.length > 0) return found;
    }
  }
  return [];
};
```

**Complexity:** O(n) where n = total nodes in tree
**Why recursive?** Folder could be at any depth (e.g., `src/lib/coderef`)

**Use Case:**
```tsx
<FileTree filterPath="coderef" />
// Shows only coderef/ directory contents, hides rest of project
```

### Favorites Filtering (showOnlyFavorites)

**Purpose:** Show only favorited items (and their parent directories)

**Algorithm:**
```typescript
const filterTreeToFavorites = (nodes: TreeNode[]): TreeNode[] => {
  const filtered: TreeNode[] = [];

  for (const node of nodes) {
    const nodeFavorited = isFavorite(node.path);
    const childrenFiltered = node.children ? filterTreeToFavorites(node.children) : [];

    // Include if favorited OR if any children are favorited (keep parent structure)
    if (nodeFavorited || childrenFiltered.length > 0) {
      filtered.push({
        ...node,
        children: childrenFiltered.length > 0 ? childrenFiltered : node.children,
      });
    }
  }

  return filtered;
};
```

**Why include parent directories?**
- Preserves tree structure (user sees full path to favorited file)
- Allows expanding parent to see favorite children

**Example:**
```
Original Tree:
  src/
    lib/
      utils.ts [FAVORITE]
      other.ts

Filtered Tree:
  src/
    lib/
      utils.ts [FAVORITE]
  (other.ts is hidden)
```

### Filter Application Order

**Pipeline:**
```typescript
let displayTree = tree;

// 1. Folder filter first
if (filterPath) {
  displayTree = filterTreeToFolder(displayTree, filterPath);
}

// 2. Special case: Hide index.json in .coderef filter
// (file is 15MB, exceeds 10MB API limit)
if (filterPath === '.coderef') {
  displayTree = displayTree.filter(node => node.name !== 'index.json');
}

// 3. Favorites filter second
if (showOnlyFavorites) {
  displayTree = filterTreeToFavorites(displayTree);
}
```

**Why this order?**
- Folder filter reduces tree size first (performance)
- Special `.coderef` filter removes large index.json file (prevents API errors)
- Favorites filter then applied to smaller tree
- Combining all: "Show favorites in coderef/ folder only (excluding index.json)"

---

## Integration Points

### Internal Integrations

**Components that use this:**
- `widgets/coderef-explorer/CodeRefExplorerWidget.tsx` - Main widget
  - Passes: `project`, `selectedPath`, `onFileClick`, favorites props
  - Receives: File click events

**Components this uses:**
- **FileTreeNode** - Recursive node rendering
  - Passes: `node`, `depth`, `selectedPath`, favorites callbacks, `moveSubmenu`, `onTreeRefresh`
  - Renders directory/file icons, expansion controls, favorites star, context menu
- **FavoritesList** - Favorites-only view
  - Passes: `favoritesData`, group management callbacks, `moveSubmenu`, `onTreeRefresh`
  - Displays grouped favorites with drag-and-drop, context menu

### External Integrations

**Hybrid Router (local + API):**
```typescript
const result = await loadProjectTree(proj);
// result = { data: TreeNode[], mode: 'local' | 'api' }
```

**Electron IPC (local mode):**
- Calls `window.electron.coderef.getTree(path)`
- Returns tree immediately (no HTTP latency)
- Requires Electron preload script

**HTTP API (API mode):**
- Calls `GET /api/coderef/tree?projectId={id}`
- Returns tree via JSON response
- Fallback when local mode unavailable (browser)

**Projects Context (useProjects hook):**
- Accesses global projects list from ProjectsContext
- Used to build move submenu with all available projects
- Projects loaded once, cached in context
- Triggers move submenu rebuild when projects change

### Data Flow

**Input:**
```typescript
<FileTree
  project={selectedProject}        // Project to load tree from
  customTree={aggregatedTree}      // Or custom tree data
  selectedPath="/src/index.ts"     // Active file
  onFileClick={(node) => {...}}    // Click handler
  filterPath="coderef"             // Optional filter
  showOnlyFavorites={true}         // Favorites mode
  favoritesData={favoritesData}    // Favorites data
  // ... callbacks
/>
```

**Processing:**
1. Load tree from project (or use customTree)
2. Preload move submenu (if projects available)
3. Apply folder filter if specified
4. Apply special `.coderef` filter (hide index.json)
5. Apply favorites filter if specified
6. Render filtered tree with FileTreeNode

**Output:**
- Rendered tree UI
- File click events emitted via `onFileClick(node)`
- Favorites toggle events via `onToggleFavorite(path, group)`
- Tree refresh callback via `onTreeRefresh()` (after file operations)
- Move submenu structure via `moveSubmenu` prop (for context menus)

---

## View Modes

### Projects Mode (Default)

**Behavior:**
- Load full project tree
- Show all files/directories
- Optional folder filter (e.g., `filterPath="coderef"`)

**UI:**
```
â””â”€â”€ src/
    â”œâ”€â”€ components/
    â”œâ”€â”€ lib/
    â””â”€â”€ index.ts
```

### CodeRef Mode (customTree)

**Behavior:**
- Use provided `customTree` prop (bypasses project loading)
- Typically aggregated `coderef/` trees from multiple projects
- No access mode indicator (custom data source)

**UI:**
```
â””â”€â”€ coderef/
    â”œâ”€â”€ workorder/
    â”œâ”€â”€ foundation-docs/
    â””â”€â”€ standards/
```

### Favorites Mode (showOnlyFavorites)

**Behavior:**
- Render `FavoritesList` component instead of tree
- Show grouped favorites (if groups exist)
- Allow drag-and-drop to assign favorites to groups

**UI:**
```
ðŸ“Œ Favorites
  Ungrouped
    âœ“ src/utils.ts
  Backend (3)
    âœ“ src/api/routes.ts
    âœ“ src/db/schema.ts
```

---

## Empty & Error States

### Empty State 1: No Project Selected

**Condition:** `!project && !customTree`

**UI:**
```tsx
<FolderOpen className="w-12 h-12 opacity-50" />
<p>Select a project to browse files</p>
```

### Empty State 2: Filtered Tree Empty

**Condition:** `displayTree.length === 0` (after filtering)

**UI:**
```tsx
<FolderOpen className="w-12 h-12 opacity-50" />
<p>
  {filterPath ? `No ${filterPath}/ folder found` : 'No files found'}
</p>
```

### Loading State

**Condition:** `loading === true` or `externalLoading === true`

**UI:**
```tsx
<Loader2 className="animate-spin" />
<p>Loading file tree...</p>
```

### Error State

**Condition:** `error !== null`

**UI:**
```tsx
<AlertCircle className="text-red-500" />
<strong>Error loading tree:</strong>
<div>{error}</div>
```

**Error Sources:**
- Network failure (API mode)
- IPC failure (Electron mode)
- Permission denied (filesystem access)
- Invalid project path

---

## Access Mode Indicator

### Purpose

**Visual Feedback:** Show user whether tree was loaded from local filesystem or API

**Why it matters:**
- **Local mode:** Instant tree loading (no network latency)
- **API mode:** Slower (HTTP round-trip), but works in browser

### UI

**Local Mode:**
```tsx
<Zap className="text-green-500" />
<span>Local Mode (Fast)</span>
```

**API Mode:**
```tsx
<Cloud className="text-blue-500" />
<span>API Mode</span>
```

**When Hidden:**
- `customTree` provided (no loading, no mode)
- `accessMode === null` (not loaded yet)

---

## Move Submenu System

### Purpose

**File Operations:** Enables moving files/directories between projects and directories via context menu

**Why preload?**
- Move menu requires loading all project trees to show directory structure
- Building menu once (not per node) avoids redundant API/filesystem calls
- Menu structure cached until projects list changes

### Implementation

**buildMoveSubmenu() Function:**
```typescript
const buildMoveSubmenu = async (): Promise<any[]> => {
  const items: any[] = [];
  
  for (const proj of projects) {
    const result = await loadProjectTree(proj);
    const tree = result.data;
    
    items.push({
      label: proj.name,
      icon: FolderOpen,
      destination: projPath,
      submenu: [
        { label: '(Root)', icon: FolderOpen, destination: projPath },
        ...buildDirectorySubmenu(tree, projPath)
      ]
    });
  }
  
  return items;
};
```

**buildDirectorySubmenu() Function:**
```typescript
const buildDirectorySubmenu = (
  treeNodes: TreeNode[],
  projectPath: string,
  depth: number = 0
): any[] => {
  if (depth > 5) return []; // Prevent infinite recursion
  
  return treeNodes
    .filter(n => n.type === 'directory')
    .map(dir => ({
      label: dir.name,
      icon: Folder,
      destination: `${projectPath}/${dir.path}`,
      submenu: dir.children 
        ? buildDirectorySubmenu(dir.children, projectPath, depth + 1)
        : undefined
    }));
};
```

**Menu Structure:**
```
Project Name
â”œâ”€â”€ (Root)
â””â”€â”€ Directory
    â”œâ”€â”€ Subdirectory
    â”‚   â””â”€â”€ ...
    â””â”€â”€ ...
```

**Performance:**
- Built once on component mount (when projects available)
- Rebuilt only when `projects` array changes
- Max depth: 5 levels (prevents infinite recursion)
- Passed to FileTreeNode and FavoritesList (shared across all nodes)

---

## Performance Considerations

### Performance Budgets

**Metrics:**
- Tree loading time (local vs API)
- Filtering time (folder + favorites)
- Render time (recursive FileTreeNode)

**Targets:**
- **Local mode loading:** <100ms (Electron IPC)
- **API mode loading:** <500ms (HTTP)
- **Filtering:** <50ms (pure JavaScript, no DOM)
- **Render:** <200ms for 500 nodes

### Bottlenecks

**1. Non-Virtualized Rendering**
- **Issue:** All nodes rendered at once
- **Impact:** Slow for projects with 1000+ files
- **Mitigation:** Consider react-window or react-virtualized

**2. Recursive Filtering**
- **Issue:** O(n) complexity for each filter
- **Impact:** Minimal for typical trees (<500 nodes)
- **Mitigation:** Acceptable, caching not needed

**3. Re-Rendering on Favorites Toggle**
- **Issue:** Parent re-renders trigger all FileTreeNode re-renders
- **Impact:** Minor jank when toggling favorites
- **Mitigation:** Memoize FileTreeNode with React.memo

**4. Move Submenu Building**
- **Issue:** Loading all project trees for move menu (async operation)
- **Impact:** Initial delay when projects list changes
- **Mitigation:** Preload once, cache until projects change, max depth limit (5)

### Optimization Opportunities

**Quick Wins:**

**1. Memoize Filtered Tree**
```tsx
const displayTree = useMemo(() => {
  let result = tree;
  if (filterPath) result = filterTreeToFolder(result, filterPath);
  if (showOnlyFavorites) result = filterTreeToFavorites(result);
  return result;
}, [tree, filterPath, showOnlyFavorites, isFavorite]);
```

**2. Memoize FileTreeNode**
```tsx
const MemoizedFileTreeNode = React.memo(FileTreeNode);
```

**3. Optimize Move Submenu Building**
- Only rebuild when projects change (already implemented)
- Consider lazy loading: build submenu on first context menu open
- Cache project trees separately (avoid reloading for move menu)

---

## Testing Strategy

### Coverage Gaps

- [ ] Test folder filtering with nested directories
- [ ] Test special `.coderef` filter hides index.json
- [ ] Test favorites filtering preserves parent structure
- [ ] Test error handling (network failure, invalid project)
- [ ] Test access mode indicator display
- [ ] Test switching between tree/favorites modes
- [ ] Test move submenu building and structure
- [ ] Test tree refresh after file operations
- [ ] Test large trees (1000+ nodes)

### Recommended Tests

**High Priority:**

**1. Test folder filtering**
```typescript
test('should filter tree to coderef folder', () => {
  const tree = [
    { name: 'src', type: 'directory', children: [...] },
    { name: 'coderef', type: 'directory', children: [
      { name: 'workorder', type: 'directory', children: [] }
    ]}
  ];

  render(<FileTree customTree={tree} filterPath="coderef" />);
  expect(screen.getByText('workorder')).toBeInTheDocument();
  expect(screen.queryByText('src')).not.toBeInTheDocument();
});
```

**2. Test favorites filtering**
```typescript
test('should show only favorited items and their parents', () => {
  const isFavorite = (path: string) => path === '/src/lib/utils.ts';

  render(<FileTree tree={tree} showOnlyFavorites isFavorite={isFavorite} />);

  expect(screen.getByText('src')).toBeInTheDocument();     // Parent
  expect(screen.getByText('lib')).toBeInTheDocument();     // Parent
  expect(screen.getByText('utils.ts')).toBeInTheDocument(); // Favorite
  expect(screen.queryByText('other.ts')).not.toBeInTheDocument();
});
```

---

## Footer

**Generated by:** Resource Sheet Generation Workflow
**Timestamp:** 2026-01-02
**Last Updated:** 2026-01-09
**Modules Used:** architecture, integration, state-management, filtering, performance, move-operations
**Complexity Score:** High (455 lines, recursive algorithms, hybrid routing, multiple view modes, move submenu system)

**Recommended Next Steps:**
1. Implement virtual scrolling for large trees
2. Add memoization for filtered tree
3. Add comprehensive filtering tests (including special `.coderef` filter)
4. Test move submenu building and performance
5. Test tree refresh callback after file operations
6. Measure render performance with large trees
7. Consider lazy loading for move submenu (build on first open)

---

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
